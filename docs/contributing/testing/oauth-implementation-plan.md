# OAuth BDD Testing Implementation Plan

## Executive Summary

The OAuth BDD testing infrastructure has a fundamental architectural gap: tokens generated by the mock OAuth server never reach muster's internal OAuth manager, causing `GetTokenByIssuer()` to always return `nil`. This document provides a complete analysis and implementation plan to fix it.

## Architecture Overview

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                           BDD Test Scenario                                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  Test Runner â”‚â”€â”€â”€â”€â–¶â”‚   Muster     â”‚â”€â”€â”€â”€â–¶â”‚  Protected Mock MCP Server   â”‚ â”‚
â”‚  â”‚  + MCP Clientâ”‚     â”‚   Serve      â”‚     â”‚  (validates against OAuth)   â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚  (separate   â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚         â”‚             â”‚   process)   â”‚                     â”‚                â”‚
â”‚         â”‚             â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜                     â”‚                â”‚
â”‚         â”‚                    â”‚                             â”‚                â”‚
â”‚         â”‚                    â–¼                             â–¼                â”‚
â”‚         â”‚             â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”‚
â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚        Mock OAuth Server              â”‚              â”‚
â”‚                       â”‚  (validates tokens for protected MCP) â”‚              â”‚
â”‚                       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚
â”‚                                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## The Core Problem

### Current Behavior

1. **Mock OAuth Server** (`internal/testing/mock/oauth_server.go`):
   - Stores tokens in its own `issuedTokens` map
   - Protected MCP servers validate tokens against this store âœ“

2. **Muster's OAuth Manager** (`internal/oauth/manager.go`):
   - Has its own `TokenStore` for session tokens
   - Aggregator calls `GetTokenByIssuer(sessionID, issuer)` to get tokens
   - This store is EMPTY because tokens never reach it

3. **The Gap**:
   - `test_inject_token` adds tokens to mock OAuth server only
   - `test_simulate_oauth_callback` creates fake state that muster doesn't recognize
   - Muster's `HandleCallback` validates state and rejects it

### Impact

When the aggregator tries to call a protected tool:
1. It calls `oauthHandler.GetTokenByIssuer(sessionID, issuer)` â†’ returns `nil`
2. No token = no `Authorization: Bearer` header sent
3. Protected MCP server returns 401
4. Aggregator marks server as `StatusAuthRequired`
5. Tools remain unavailable

## Token Stores Comparison

| Store | Location | Purpose | Accessible By |
|-------|----------|---------|---------------|
| Mock OAuth Server | `mock.OAuthServer.issuedTokens` | Validate tokens for protected MCP servers | Mock infrastructure |
| Muster Token Store | `oauth.TokenStore.tokens` | Store tokens for aggregator to use | Muster process only |

## Complete OAuth Flow (What Should Happen)

```
1. Test calls protected tool          â†’ Aggregator proxies to protected MCP server
2. Protected MCP returns 401          â†’ Aggregator marks server as auth_required
3. Aggregator exposes authenticate_X  â†’ Synthetic tool appears in tool list
4. Test calls authenticate_X          â†’ Muster calls CreateAuthChallenge()
                                         - Generates PKCE verifier
                                         - Stores state in StateStore
                                         - Returns auth URL with real state
5. Test parses auth URL               â†’ Extracts state, redirect_uri, etc.
6. Test generates auth code           â†’ Mock OAuth server stores code
7. Test calls muster callback         â†’ GET /callback?code=XXX&state=YYY
8. Muster validates state             â†’ Finds it in StateStore âœ“
9. Muster exchanges code              â†’ POST to mock OAuth /token endpoint
10. Mock OAuth returns token          â†’ Muster stores in TokenStore
11. Test retries protected tool       â†’ Aggregator finds token, sends it
12. Protected MCP validates token     â†’ Against mock OAuth server âœ“
13. Tool executes successfully        â†’ Protected tools now available
```

## Implementation Plan

### Phase 1: API Layer Changes (Completed)

**Files Modified:**
- `internal/api/oauth.go` - Added `StoreTokenForTesting()` to interface
- `internal/oauth/api_adapter.go` - Implemented adapter method
- `internal/oauth/manager.go` - Implemented `StoreTokenForTesting()`

These changes allow direct token injection into muster's token store for testing.

### Phase 2: Test Tools Enhancement (In Progress)

**File:** `internal/testing/test_tools.go`

#### Option A: Enhanced `test_simulate_oauth_callback` (Recommended)

The tool should orchestrate the complete OAuth flow:

```go
func (h *TestToolsHandler) handleSimulateOAuthCallback(ctx context.Context, args map[string]interface{}) (interface{}, error) {
    // 1. Call authenticate_<server> via MCP
    authURL, err := h.callAuthenticateTool(ctx, serverName)
    
    // 2. Parse state from auth URL
    state := parsedURL.Query().Get("state")
    
    // 3. Generate auth code in mock OAuth server
    authCode := oauthServer.GenerateAuthCode(clientID, redirectURI, scope, state, codeChallenge, codeChallengeMethod)
    
    // 4. Call muster's callback endpoint
    resp, err := http.Get(callbackURL)
    
    // 5. Muster handles callback, stores token
    return success
}
```

**Requirements:**
- TestToolsHandler needs access to MCP client
- Test runner must call `testToolsHandler.SetMCPClient(scenarioClient)` after creating handler

**File Changes:**
```go
// internal/testing/test_runner.go (around line 393)
testToolsHandler := NewTestToolsHandler(r.instanceManager, instance, r.debug, r.logger)
testToolsHandler.SetMCPClient(scenarioClient)  // ADD THIS LINE
```

#### Option B: Direct Token Injection via HTTP

Add an HTTP endpoint to muster for testing:

```go
// internal/oauth/handler.go
func (h *Handler) HandleTestInjectToken(w http.ResponseWriter, r *http.Request) {
    // Only in test mode
    // Parses JSON body with sessionID, issuer, scope, token
    // Calls manager.StoreTokenForTesting()
}
```

This would require:
- Adding test mode flag to muster serve
- Registering test-only HTTP endpoint
- Updating test tools to call this endpoint

### Phase 3: Update test_inject_token

The `test_inject_token` tool should inject tokens into BOTH stores:

```go
func (h *TestToolsHandler) handleInjectToken(ctx context.Context, args map[string]interface{}) (interface{}, error) {
    // 1. Add to mock OAuth server (for protected MCP validation)
    oauthServer.AddToken(token, refreshToken, scope, clientID, expiresAt)
    
    // 2. Add to muster's token store via HTTP endpoint
    // POST to http://localhost:<port>/test/inject-token
    // with sessionID, issuer, scope, accessToken
}
```

### Phase 4: Test Runner Updates

**File:** `internal/testing/test_runner.go`

```go
// Around line 393
testToolsHandler := NewTestToolsHandler(r.instanceManager, instance, r.debug, r.logger)
testToolsHandler.SetMCPClient(scenarioClient)  // Pass MCP client to handler
```

### Phase 5: BDD Scenario Updates

Update scenarios to use the proper flow:

```yaml
# Before (broken)
steps:
  - id: authenticate
    tool: "test_simulate_oauth_callback"
    args:
      server: "protected-server"
  - id: call-protected-tool
    tool: "x_protected-server_get_secret"

# After (working)
steps:
  - id: trigger-auth-required
    description: "Call protected tool to trigger auth requirement"
    tool: "x_protected-server_get_secret"
    expected:
      success: false
      error_contains: ["authentication required"]
  
  - id: complete-oauth-flow
    description: "Complete OAuth authentication"
    tool: "test_simulate_oauth_callback"
    args:
      server: "protected-server"
    expected:
      success: true
  
  - id: call-protected-tool-authenticated
    description: "Now call protected tool with authentication"
    tool: "x_protected-server_get_secret"
    expected:
      success: true
```

## Files Changed Summary

| File | Status | Changes |
|------|--------|---------|
| `internal/api/oauth.go` | âœ… Done | Added `StoreTokenForTesting()` interface method |
| `internal/oauth/api_adapter.go` | âœ… Done | Implemented adapter method |
| `internal/oauth/manager.go` | âœ… Done | Implemented `StoreTokenForTesting()` |
| `internal/testing/test_tools.go` | ğŸ”„ In Progress | Enhanced OAuth simulation, added MCP client field |
| `internal/testing/test_runner.go` | â³ Pending | Pass MCP client to TestToolsHandler |
| OAuth BDD scenarios | â³ Pending | Update to use proper flow |

## Testing Checklist

After implementation, verify:

- [ ] `test_simulate_oauth_callback` calls authenticate tool first
- [ ] State from auth URL is used in callback
- [ ] Muster's callback successfully exchanges code for token
- [ ] Token appears in muster's TokenStore
- [ ] Subsequent tool calls include Bearer token
- [ ] Protected MCP server validates token successfully
- [ ] Protected tools become available after auth
- [ ] SSO works (same issuer = shared token)

## Run Tests

```bash
# Rebuild muster after changes
go install

# Run OAuth-specific scenarios
muster test --scenario oauth-protected-mcp-server --verbose --debug
muster test --scenario oauth-sso-detection --verbose --debug
muster test --scenario oauth-auth-meta-propagation --verbose --debug

# Run all tests
muster test --parallel 50
```

## Key Insights

1. **Two Token Stores**: Mock OAuth server and muster have separate token stores
2. **State Validation**: Muster validates OAuth state - fake states are rejected
3. **Process Boundary**: Muster runs as separate process - no direct function calls
4. **MCP Client Needed**: Test tools need MCP client to call authenticate tool
5. **Full Flow Required**: Must complete entire OAuth dance, not just inject tokens

## References

- ADR-004: OAuth Proxy
- ADR-005: Muster Server Auth  
- ADR-008: Unified Authentication
- `docs/contributing/testing/auth-testing-plan.md`
- `docs/contributing/testing/oauth-bdd-testing-plan.md`
